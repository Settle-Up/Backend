# 영수증 등록 (최적화)

## 유저 플로우 
유저가 영수증을 업로드 하게 되면 프론트엔드에서 영수증을 사진을 서버에게 보내고 서버는 그 영수증 사진을 을 기반으로 외부 azure api 를 호출합니다
서버는 azure api 응답 값을 프론트엔드에게 전달하고 프론트엔드에서는 정해진 형식에 따라 데이터를 정해 서버에게 두번째 요청을 보내게 됩니다 
서버는 두번째 요청에 의해 영수증을 저장하고 최적화하여 비용을 등록합니다

플로우는 아래와 같습니다 
"영수증 등록"에는 2개의 외부 api 호출 과 , 최적화가 이용이 됩니다
해당 파일에서는 최적화 과정에대해 자세히 설명드리고자 합니다 
아래의 플로우 그림에서 B의 과정입니다  

![스크린샷 2024-05-11 오후 8 47 42](https://github.com/Settle-Up/settle-up-server/assets/129722492/4d76853c-b010-4ef5-9191-9a26b592b254)

## 우리 서비스 정규화 된 영수증 형식 
그룹 내 여러번의 송금이 쌓이고 그 그룹 내에서 얽혀 있는 채무 관계를 단순화 하는 것이 목표였습니다
그러기 위해서는 영수증으로 부터 얻은 비용이 "어떻게" 할당 되는지 문제가 우선이 였습니다 

실제로 이루어지는 그룹간의 거래 관계를 반영하기 위해 저희가 더치페이를 할 때 가정하는 상황들을 나열하고 
영수증을 통해 분할은 크게 두가지로 이루어진다는 것에 합의에 도달했습니다

가정은 두가지로 나뉩니다 
C1) 아이템 균등분할- 구성원이 아이템 마다 인원 수 대로 1/n 을 하는 경우와 
C2) 아이템 차등분할- 각각의 구성원이 아이템마다 구매한 아이템 갯수가 달라서 아이템마다 다르게 할당하는 경우입니다 

영수증을 토대로 저희는 
영수증과  상세 내용, 각 유저 관계를 저장을 해야 했으며 
1. 영수증의 기본적인 내용을 담은 테이블(receipt) - id,  영수증 uuid , 영수증 이름 , group(일대다 관계) , 주소 , 날짜 , 돈낸 사람 , 총 금액 , 할인 적용 여부 , 실제로 낸 가격 , 분할 형식 , 생성날짜 
2. 영수증 기본내용과 아이템을 이어주는 테이블(receipt_item) - id , receipt(일대다 관계) ,아이템이름 , 총 갯수 , 개당 가격 , 참여 구성원  
3. 영수증 아이템과 유저의 관계를 풀어 줄 테이블(receipt_item_user) -id , receipt_item(일대다 관계) , 유저의 구매 갯수 , user(일대다 관계)

필요하다고 판단하였습니다
![스크린샷 2024-05-12 오후 3 57 04](https://github.com/Settle-Up/settle-up-server/assets/129722492/9728e498-6c3f-4e6b-b473-32d2402fe12c)

자세한 예를 들어 A, B , C  로 구성이 되어 있는 그룹의 일회성 영수증을 통한 유저 플로우를 살펴보겠습니다 

1번 째 영수증에서 A가 34,000원의 타코집에서 돈을 쓰고 
구성원은 A , B , C 였습니다 
내역은 다음과 같습니다

| 상품명(아이템) | 갯수 | 개당 가격 | 총 가격 |
|---------------|------|-----------|---------|
| 가 타코        | 2    | 5,000     | 10,000  |
| 나 타코        | 3    | 5,000     | 15,000  |
| 다 맥주        | 3    | 3,000     | 9,000   |


이런 영수증을 토대로  유저는 
각각 아이템 마다 균등분할 또는 차등분할을 할지 선택할 수 있는 선지가 주어집니다 

<차등 분할>을 선택한다는 가정을 한다면 

| 상품명(아이템) | 갯수 | 개당 가격 | 총 가격 | 참여구성원 | 갯수 |
|---------------|------|-----------|---------|------------|------|
| 가 타코        | 2    | 5,000     | 10,000  | B          | 2    |
| 나 타코        | 3    | 5,000     | 15,000  | A          | 2    |
|               |      |           |         | C          | 1    |
| 다 맥주        | 3    | 3,000     | 9,000   | C          | 2    |
|               |      |           |         | A          | 1    |

                                 
이런식으로 같은 아이템이라도 각 구성원이 아이템 구매 갯수에 차등을 둘 수 있도록 했습니다 


<균등분할>을 선택한다는 가정을 한다면 

| 상품명(아이템) | 갯수 | 개당 가격 | 총 가격 | 참여 구성원 |
|---------------|------|-----------|---------|------------|
| 가 타코        | 2    | 5,000     | 10,000  | B          |
| 나 타코        | 3    | 5,000     | 15,000  | A, C       |
| 다 맥주        | 3    | 3,000     | 9,000   | A, C       |

위와 같이 선택할 수 있도록 하였습니다 
형식에서 필수 부분이 빠진 것은 controller 에서 유효성 검사로 잡을 수 있도록 설계 했습니다

## 영수증 등록 후 최적화 과정 
최적화 과정은 service에서 영수증이 등록 된 후 controller 로 반환값을 전달하고 
응답 메세지 인스턴스를 만들기 직전에 이벤트를 발행하여 , 리스너가 발행한 이벤트를 감지하고 최적화 과정들을 호출합니다

이렇게 설계한 이유는 유저의 입장에서 "영수증 등록"이라는 과정이 서버에서 영수증 내용을 저장하고 난 이후의 로직상 서버 에러는 유저나 프론트에서 불필요한 메세지로 느껴져서 
최적화 과정에서 나오는 exception의 경우 sentry 를 이용하여 서버에 등록된 이메일과 디스코드로 메세지를 보낼 수 있게 하여 서버작업자가 모니터링 할 수 있도록 설계하였습니다 

리스너의 호출로 인하여 최적화 과정은
크게 5가지 과정으로 이루어 집니다 
1. 등록된 영수증을 각각의 보낼 돈이 있는 사람마다 payer 와 recipent 간의 채무관계 설정하기 - 거래원장 생성 (RequireTransaction) 
2. 그룹 내 모든 거래관계에서 개인간의 거래가 중복되면 1개의 거래로 최적화하기 - 1차 최적화(OptimizedTransaction)
3. 그룹 내 각 유저의 받거나, 줘야할 돈을 합산한 순수하게 내가 받거나 줘야할 돈 계산 - 순액 구하기 (net)
4. 거래의 흐름이 같은 금액이 계속된다면 (A->(500)-> B , B->(500)-> C 결과적으로 A는 C에게 500원을 주면됌 ) 새로운 거래 생성하기 - 2차 최적화 (groupOptimizedTransaction)
5. 새로운 거래의 생성으로 개인간의 거래가 중복될 수 있는 가능성을 고려해 , 개인간의 거래 다시 1개로 최적화 - 3차 최적화 (UltimateTransaction)


## 거래 원장 생성 (RequireTransaction)

### 목적:
영수증을 등록한 뒤에 대표로 돈을 낸 사람에게 
빚진 유저가 자신이 구매한 아이템 가격과 아이템 갯수를 토대로 줘야할 돈을 기록하는 용도입니다

### 개발시 고려사항:
저희는 균등배분과 , 차등배분으로 유저에게 아이템 마다 가격을 배분하는 자율성을 주기로 하였습니다 
이에 균등 배분 , 차등 배분 시 들어와야 할 필드 값은 다르지만 각각의 경우에 코드를 이분화하면 중복되는 코드가 너무 많아 두 가지 경우 모두 포함 할 수 있는 코드로 작성했습니다 

## 1차 최적화 (OptimizedTransaction)

### 목적 :
그룹 내 두명의 유저가 형성할 수 있는 거래 횟수를 1번 또는 0 번으로 최적화하는 과정입니다 
그룹이 A,B,C,D,E 라는 구성원이 있다면 
A-B ,A-C ,A-D ,A-E ,B-C ,B-D ,B-E ,C-D ,C-E ,D-E
의 관계에서 일어날 수 있는 여러번의 거래를 한번으로 최적화하는 것이 기본적인 최소화라고 고려했습니다 

이에 영수증이 추가 될때 마다 무조건 적으로 이벤트 리스너의 호출을 받아 거래 원장을 생성하고 , 1차 최적화 과정에 들어 갑니다 

### 개발방법:
1. 그룹 내 인원이 2명이서 이룰 수 있는 관계를 정의 : 조합 (combination) 이라는 수학 공식을 이용해 2명이서 이룰 수 있는 관계를 리스트화 하였습니다 
2. combinationList 생성 [A,B][A,C][A,D][A,E][B,C][B,E][C,D][C,D][C,E][D,E]
3. combinationList 를 토대로 requireTransaction 에서 sender(채무자) 와 reciptent(채권자) 관계를 형성하는 것을 찾음
4. 채무자와 채권자의 관계에서 combiationList 의 배열 [0]이 sender 일 경우 totalAmount 에 금액을 차감하고 , reciptent 일 경우 totalAmount 에 금액을 더하는 식으로 loop 문 실행
5. 최종적으로 나온금액이 " 0 "이라면 새로운 거래를 생성하지 않고 requireTransaction 에 최적화과정 중 상속에 의한 거래 clear
6. 최종적으로 나온금액이 - 라면 combinationList 의 배열 [0]을 reciptent , 배열 [1]을 sender 로 하고 + 라면 그 반대로 거래를 생성
7. OptimizedTransaction 엔티티에 저장

## 순액 구하기 

### 목적 :
그룹내 각 유저가 영수증을 추가한 현재시점에 타인에게 받아야할 돈 또는 타인에게 주어야 할 돈의 순액을 구하기 위한 로직
2차 최적화 시 DFS 를 도는 기반이 되고 , 2차 , 3차 최적화시 로직 오류로 송금관계가 꼬일 경우를 대비하여 증명을 위해 둔 장치

## 2차 최적화 (groupOptimizedTransaction)

### 목적 :
개인간의 거래는 한개로 최소화되었지만 아래와 같은 경우를 고려했습니다
<img width="823" alt="스크린샷 2024-05-12 오후 9 09 44" src="https://github.com/Settle-Up/settle-up-server/assets/129722492/feda16b1-0577-4789-8369-167ebdd86cc2">

가) 상황을 보면 각유저는 1차 최적화 결과 다른 유저와 한개의 거래만을 형성하고 있습니다 
하지만 저희 서비스는 그룹 내"최소송금" 방안을 제안드리기 위해
나)와 같이 가중치가 같은데 연속되는 경우에 집중했습니다 

A->C->E->D 의 경우에 A 가 바로 D에게 만원을 송금하면 3번의 송금이 줄어 들어 그룹내 이익이 커질 것이라고 판단하였습니다 
이에 2차 최적화를 진행하기로 했습니다 

### 개발방법:
그래프 알고리즘 과 DFS 활용
1. 먼저 그룹 내 개인을 "노드"라는 개념으로 보기로 했습니다
2. DFS 설계원칙
   - DFS 시작점을 어떤 노드로 할지에 대한 점에서는 순액에 따라 빚이 가장 많은 사람 부터 도는 방식을 선택했습니다 , 만약 빚이 같은 사람이 있다면 유저의 Fk 의 순서가 숫자가 작은 사람 부터 돌도록 하였습니다
   - 이전 가중치와 현재가중치가 같다면 , 새로운 가중치가 나오기 전까지 방문배열에 기록을 하고 가중치가 달라지면 이전에 기록해두었던 배열의 시작과 끝을 노드로 하여 새로운 엣지를 만드는 방식을 선택했습니다
3. 그래프 알고리즘 설계 원칙
   - 그래프를 구성하기 위해 JGraph T 라이브러리를 활용 
   - Vertex(정점)을 senderId 와 reciptentId 로 지정
   - Edge 에는 가중치(총금액)과 거래 아이디가 들어가야하는 상화 하지만 해당 라이브러리기능은 엣지에 두가지 정보를 한번에 넣을 수 없으므로 OOP 원칙에 따라 graph 와 엣지의 정보를 담는 객체를 생성하여 값을 도출
4. 설계 시 신경쓴 부분
   - createGraphFromTransactions 메소드는 객체지향 프로그래밍(OOP)의 핵심 원칙을 적용하여 개발된 기능입니다.
     특히, 캡슐화와 추상화 원칙을 활용하여, 거래 데이터를 그래프의 형태로 변환하고 이를 다루기 위한 복잡한 로직을 숨겨, 외부에서는 간단하게 그래프 객체를 통해 거래 관계와 흐름을 조작할 수 있게 합니다

## 3차 최적화 

### 목적:
2차 최적화가 일어난다면 아래와 같이 거래 관계가 변동이 있을 것입니다 
<img width="881" alt="스크린샷 2024-05-12 오후 9 53 56" src="https://github.com/Settle-Up/settle-up-server/assets/129722492/71ae7529-efdb-42c6-ad76-b0b6b3e73ac6">

다) 의 경우 2차 최적화로 인한 결과입니다 
A 와 D 사이에 중복되는 거래가 생성된 것을 볼 수 있습니다 

이런 경우를 대비하여 "2차 최적화로 인해 새로운 에지가 형성이 된다면" 3차 최적화가 호출이 될 수 있도록 설계하였습니다 
만약 가중치가 연속되는 것이 없어서 2차 최적화로 인한 결과가 생성이 되지 않는다면 , 중첩되는 거래를 없을 것이며 이럴 경우 3차 최적화를 호출하는 것은 메모리의 낭비라고 생각했기 때문입니다 

3차 최적화의 경우 1차 최적화와 비슷한 방식으로 조합이라는 수학공식을 이용해 그룹내 두 유저간의 관계 형성 후 
1. 1차 최적화 결과 - 2차 최적화를 위해 쓰인 1차 최적화 거래 제외
2. 2차 최적화 결과 
1 번 2번을 추합하여 대상을 좁히고 두 유저간의 하나의 거래만이 생성되도록 채무 관계를 재조정 합니다


 


